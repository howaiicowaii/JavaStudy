package com.sist.main;
/*
     언어 : 자바, 파이썬, C/C++, 코틀린, 스칼라, C#...
           ---------
     ML : HTML,  MXL, WML, HDML, VML
          ----------
     JavaScript : JQuery(AJax) ,Vue, React, TypeScript 
                  ------------------------  ----------
                  coffieScript, NodeJs, NextJs
     기술 : Spring, Spring-Boot 
     구조 : AWS / MSA 
     --------------------------------------------------- 
       => R, NumPy, Pandas => 아나콘다, MatPlotLib
       => 머신러닝 / 딥러닝
     IT => 공부하는 방식 => 새로운 거 계속 배우다 모르는 부분 찾아서 복습하는 방식
     ==> 실무 => 구현 (이론 => 면접)
	자바 
	 = 데이터형 => 변수 (2장)
	    정수 : byte, int, long 
	          ----       ---- 데이터분석 (빅데이터)
	    실수 : double
	    논리 : boolean 
	    문자열 : String 
	          | 파일입출력 (io)
	 = 처리 => 연산자 / 제어문 (3장,4장)
	    단항연산자 : 증가연산자(++,--), 부정연산자(!), 형변환연산자(type)
	              형변환 : 자동형변환, 강제형변환 
	              ----- 클래스도 적용 
	                    ---- 크기 (상속,포함이 있어야 크기를 잴 수 있다) => instanceOf
	    이항연산자 : 산술연산자(+,-,*,/,%)
	              비교연산자(===,!=,<,>,<=,>=)
	              논리연산자(&&, ||) 
	              대입연산자(=, +=, -=)
	    삼항연산자 : ? : 
	    제어문 
	      = 조건문 
	        -------------------
	        if(조건문) => 단일조건문 
	        if~else => 선택조건문 
	        ------------------- > 반드시 공부 (다중조건문은 가끔 나온다)
	        if~else if~else => 다중조건문 
	      = 반복문 
	        for(화면 출력), while(데이터베이스, 파일)
	         Front         Back
	         => 2차 for문 
	      = 반복제어문 
	        break => 반복문 종료 
	 = 배열 => 1차원 배열 
	          => 클래스 배열 
	          Music[] String[] ==> 컬렉션 (배열 보완)(가변형)
	                               ---- 12장 (핵심)
	 = 클래스 (5장,6장,6장)
	   구성요소 
	   ------ 
	    멤버변수 
	      = 인스턴스 변수 (중심) ==> 메모리를 따로 저장 
	      = 정적변수(static)(=공유변수) ==> 메모리 공간을 한개만 사용 (공유)
	        ----------------------
	         => 디자인 패턴 : 싱글턴 패턴 => 데이터베이스 연동 
	         => 팩토리 패턴 
	         => 스프링 => 8개 패턴은 알아야한다 (컴바인드 패턴)
	      = 데이터 보호해줘야 한다 => 캡슐화 => private => 읽기/쓰기 => getter/setter
	    메소드 
	      = 다른 클래스와 연결 
	      = 인스턴스메소드 : 메모리에 따로 저장
	        => 호출 
	           객체명.메소드명()
	           scan.nextInt()
	           s.replace()
	      = 정적메소드(static) : 공유(한개의 메소드로 모든 객체 사용)
	           클래스명.메소드명()
	           Math.random()
	           String.valueOf() 
	        => 한글변환 
	        
	        => 메소드
	           접근지정어 : public 
	           리턴형 : 기본형 , 클래스형 , 배열 
	                          ------------ 1개로 본다 (묶었기 때문)
	              => 결과값 1개 
	              => 목록 , 상세보기 , 검색결과 => 배열, 클래스 
	           메소드명 : 식별자 => 소문자로 시작 
	           매개변수 : 여러개 사용 => 사용자 요청값 
	                    3개 이상이면 => 클래스, 배열 
	                    => 회원가입 , 게시물 글쓰기 , 영화 정보 올리기
	    생성자
	      = 멤버변수 초기화, 시작과 동시에 처리할 때 
	      = 메모리 할당시 호출
	      = 클래스는 반드시 생성자 1개 이상이 필요
	        => 없으면 자동 추가 (디폴트 생성자)(매개변수 없는 생성자)
	      *** 자동 추가 
	       1) import 자동 추가 
	          import java.lang.*;
	                 ---------- String, Math, Object, System
	       2) 모든 클래스(라이브러리,사용자 정의 클래스)
	          => Object로 부터 상속 받는다
	          class MainClass (extends Object) => 생략가능 
	       3) 모든 메소드는 return(메소드 종료)
	          => void 일 경우 자동으로 return 추가 (생략가능)
	          void aaa()
	          {
	          	 // return;
	          }
	       4) class A
	          {
	             -------------
	              public A(){}  // 생성자 자동 추가 
	             -------------
	          }
	       5) 자바에서 지원하는 모든 클래스는 예외처리를 가지고 있다
	          CheckException UnCheckException
	                         ---------------- 예외처리 생략
	                |
	              네트워크 : URL, Socket...
	              IO : 파일 입출력
	              SQL : 오라클 연결 
	       생성자를 사용하지 않고 초기화 하는 방법 
	       ------------------------------
	        초기화 블록 
	         = 인스턴스 블록 => 생성자
	         = static 블록 => static 변수 => 생성자를 호출하지 않아도 된다
	         
	        *** 먼저 명시적 초기화 => 불가능할 때 => 생성자나 초기화 블록 사용
	                                | 외부에서 값을 읽어서 초기화 시킬 때
	                                | 크롤링, 파일 읽기, 네트워크...
	  = 6장 : 객체지향의 3대 특성 
	         = 문법이 아니다(필수 X) , 권장 사항
	     1) 캡슐화 : 데이터 보호 
	        => 변수를 은닉화 : private
	        => 기능 설정 => getter/setter => Lombok
	     2) 재사용 : 상속 => 기존의 클래스를 확장 , 필요시에 변경하여 사용 
	               class A
	               class B extends A
	               포함 => 클래스를 변경하지 않는 상태로 사용 (있는 그대로 사용)
	               class A
	               class B
	               {
	                  A a=new A(); ==> 강제 변경 가능 => 익명의 클래스
	               }
	               
	               상속의 예외 조건 : static
	                              생성자 , 초기화 블록 
	                              private => 상속은 되지만 접근이 불가능
	               상속 => 클래스의 크기 => 형변환 
	                class A
	                class B extends A  ==> A > B
	                자동 형변환 => 묵시적 형변환 
	                 A a=new B();
	                 ------------
	                 B b=new B();
	                 A a=b;
	                강제 형변환 => 명시적 형변환 
	                 A a=new B();
	                 B b=(B)a;
	                 --------- 많이 등장 
	                 리턴형 => 클래스형 
	                  => 라이브러리에서 클래스형을 리턴 
	                     ----------------------
	                      => Object를 리턴하는 경우가 많이 있다
	                 Music getData(){}
	     3) 변경 / 추가 
	        => 다형성 
	        변경 : 오버라이딩 
	        추가 : 오버로딩 
	        
	         메소드 관련 
	              오버로딩            오버라이딩 
	     -----------------------------------------
	     상태      같은 클래스         상속을 받은 경우 
	     -----------------------------------------
	     리턴형     관계없다            동일
	     -----------------------------------------
	     메소드명    동일              동일 
	     -----------------------------------------
	     매개변수   갯수나 데이터형이 다르다 동일 
	     -----------------------------------------
	     접근지정어   관계없다           축소(X), 확대(O)
	     -----------------------------------------
	       <---------------- 축소 
	     private < default < protected < public 
	       -----------------> 확대 
	       
	     interface A
	     {
	        // 자동 추가 
	        (public abstract) void disp();
	        (public abstract) void aaa();
	     }
	     
	     => class B implements A
	        {
	           void disp();
	           void aaa();
	           ------- 오류 
	        }
	               
*/ 
import java.util.*;
/*
	class A
	{
	   void display(){}
	}
	class B extends A 
	{
	   int a,b;
	   void aaa(){}
	   -------------
	   void display(){} => 변경하면 오버라이딩
	   -------------
	}
	
	A a=new B(); ==> 추상클래스 / 인터페이스 
	--- a.display()
	B b=new B();
	--- a,b,aaa(),display()
*/
public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		List names=new ArrayList();
		// 배열 대신 사용 => 컬렉션 (갯수 지정되지 않는 가변형)
		names.add("홍길동"); // 0번             Object -> String 
		String name=(String)names.get(0); // String 으로 형변환 해줘야 한다
		                   // 하위클래스(String)으로 받아야 쓸 수 있는 메소드 늘어난다
		
	}

}
