/*
    클래스 정리 
	118p~
	지금은 프로그램 짜는 것이 아닌 
	=> 웹 개발에 필요한 자바 문법/형식/흐름 파악 중 
	       				-----------
	브라우저 (웹)     <==>  자바  <==> 오라클 (웹에 필요한 데이터가 저장)
	----------
  HTML/JavaScript/CSS
  	=> 오라클/MySQL : 데이터베이스
 단점 : 브라우저(웹)은 데이터베이스에 연결할 수 있는 프로그램이 없다 
    => 클래스 구조 
    1) 형식
       class => 필요한 모든 데이터 모아서 한번에 저장 목적
                  		 ----------
                  		 기능 / 데이터
	   ** 클래스명 => 식별자 (키워드가 아니다)
	             => 약속 => 대문자로 시작  ex) class ClassName {}
	                ---------------
	                (약속 + 들여쓰기 잘 해야 나중에 편하다)
	             => 알파벳 (한글은 깨질 위험이 있다)
	             => _MainClass : 임시 클래스 (테스트 후 사라질)
	             => 실무
	                데이터형 모은 클래스 => ~VO, ~DTO 
	                             (값만 갖고 있느냐)
	                액션(기능) 모은 클래스 => ~DAO, ~Manager, ~Service
	                 		         (오라클 연결)
	                 		         
       => 가독성을 위해 아래와 같은 순서 권장
       class 클래스명
       {
       	   -------------------------
       	    변수선언 : 멤버변수, 공유변수 ==> 자동 default 초기화
       	    멤버변수
       	    ------
       	    멤버변수(인스턴스변수) => new를 사용해서 객체 생성시에 따로 저장되는 메모리
       	          사용시) 객체명.변수명
       	          저장위치) Heap => 프로그래머 관리 영역
       	                  => 관리 소홀하다보니 => GC (자동 메모리 해제기)
       	                  => GC 대상 
       	                     객체가 null 
       	                     사용하지 않는 객체
       	                     => 멀티미디어 => System.gc()
				  사용범위) 해당 클래스 전체 
				          필요시에는 다른 클래스에서도 사용 가능
				  소멸시기) 프로그램 종료시 소멸 (메모리 낭비가 야기되기도 한다)
       	    공유변수(static)(=클래스변수) => 컴파일러에 의해 자동으로 메모리 할당
       	          사용시) 객체명.변수명
       	                클래스명.변수명
       	          저장위치) Method Area(static) => 한개만 저장 가능
       	          사용범위) 해당 클래스 전체 
				          필요시에는 다른 클래스에서도 사용 가능
				  소멸시기) 프로그램 종료시 소멸 (메모리 낭비가 야기되기도 한다)
			=> 따로 저장 / 한개 저장 
			   ------- 인스턴스변수(90%)
			   => static : 데이터 목록 , 회원 목록 , 게시물 목록
		 (공유변수)(클래스변수) -----------------------------
			                ㄴ 모든 사람이 공유하게 해주는 => (오라클)
       	   -------------------------
       	    생성자 : 반드시 필요로 한다 (생성자가 없으면 컴파일러가 자동 생성)
       	           = 멤버변수에 대한 초기화 담당
       	           = 메모리 할당 (클래스 저장할 때 호출된다)
       	           = 시작과 동시에 처리하는 명령문이 있을 때 사용
       	             (오라클 연결, 네트워크 => 서버 구동, 자동 로그인)
       	           특징)
       	            => 클래스명과 동일 
       	            => 리턴형이 없다
       	            => 여러 개를 만들 수 있다 (오버로딩) => 중복 함수 정의
       	               ** 오버로딩 조건 
       	                  1) 한개의 클래스에서 제작
       	                  2) 메소드명이 동일 
       	                  3) 매개변수의 갯수나 데이터형이 다르다
       	                     => 다른 메소드로 인식 
       	                  4) 리턴형은 관계없다
       	               ** 다른 클래스에서 객체 생성시에 반드시 => public 
       	    초기화 블록 : 멤버변수의 초기값 담당 
       	    --------
       	      인스턴스 블록 : => 인스턴스 변수, static 변수에 대한 초기화 가능 
       	      static 블록 : => static 변수만 초기화 가능
       	      
       	      class ClassName
       	      {
       	      	  변수 선언;
       	      	  
       	      	  {
       	      	  	  인스턴스 블록 
       	      	  }
       	      	  
       	      	  static
       	      	  {
       	      	  	  static 블록 
       	      	  }
       	      	  ----------------- 자동 호출 , 상속이 불가능
       	      	  *** 상속의 예외 조건 : 생성자 
       	      }
       	      
       	      => 초기화 순서 
       	         1) 명시적인 초기화 
       	         2) 초기화 블록 : static 변수에 대한 초기화 할 때
       	            --------   ------ 자동 저장
       	            
       	         3) 생성자 : 인스턴스 변수 초기화 할 때 
       	         
       	         A a=new A() // 메모리 할당 
       	             --- -- 
       	             new => int malloc(sizeof(A)) // new 로 대체 
       	                    --------------------- 사용이 많다(연산자 승격)
       	                    => 기본형 외의 데이터형은 크기를 알지 못한다
       	                    => 리턴형 = 메모리 주소
       	             A() => 변수의 초기값을 설정
       	             *** 생성자는 단독으로 호출이 불가능하다
       	                 new 생성자() << 이렇게 호출해야한다
       	                 ----------
       	   -------------------------
       	      메소드로 할 수 있는 것 ( 객체지향 3대 특성 )
       	       => 읽기 / 쓰기 => getter/setter 
       	       		=> 캡슐화 
       	       => 이미 만들어진 메소드를 변경 => 오버라이딩 
       	       => 새로운 기능을 추가 => 오버로딩  
       	       		=> 다형성 
       	       => 재사용 => is-a / has-a 
       	       		=> 상속 / 포함 
       	       ----------------------------------객체지향 프로그램 3대 특징
       	    멤버메소드(인스턴스메소드) => 클래스 영역에서만 선언/구현 
       	     = 사용자 정의 메소드 => 기능 , 반복제거 
       	       = 멤버 메소드 : new를 사용할 때마다 따로 저장 (=인스턴스메소드)
       	         => 다른 클래스와 통신할 때 주로 사용 (메세지)
       	         [접근지정어=>public] 리턴형 메소드명(매개변수 목록) // 선언부
       	         {
       	            구현부 
       	         }
       	         => 객체명.메소드명()
       	        ex) scan.nextInt()
       	              s.trim() 
       	         => 리턴형 : 사용자 요청에 대한 결과값
       	         	        => 한개만 설정 가능
       	         	        (여러개일 경우 => 배열 / 클래스)
       	         	        => 상세보기 => 클래스 <배열 : 목록> => 컬렉션 
       	         	                            |             |
       	         	                           고정           가변
       	         	        => 리턴형은 반드시 사용한다 
       	         	           결과값이 있는 경우 : return 값
       	         	           결과값이 없는 경우 : void => return 생략가능
       	         => 매개변수 : 사용자가 보내준 값 
       	                     ex) 로그인창 => id,pwd
       	                         검색기 => 검색어 
       	                         클릭 => 번호 
       	                         ----------
       	                         게시판 글쓰기
       	                         회원가입 
       	                         ---------- 클래스 (매개변수 3개이상이면)
       	                         ---------------
       	         => 멤버메소드는 멤버변수, static 변수, 지역변수를 사용할 수 있다
       	         => 메소드 유형 
       	            리턴형     매개변수 
       	            ==> R(SELECT) => 오라클에선 DML
       	              O        O
       	              O        X
       	              ------------- 메소드 자체 처리(CRUD) (void)
       	            ==> CUD => (INSERT,UPDATE,DELETE)
       	              X(void)  O
       	              X(void)  X
       	              ------------- 리턴형이 많을 수 있다 (웹)
       	              사용법)
       	              	class A
       	              	{
       	              		int a=10;
       	              		void aaa()
       	              		{
       	              			--- 구현 
       	              			return; (생략가능)
       	              		}
       	              		int bbb()
       	              		{
       	              			--- 구현
       	              			return 정수값; => 데이터형 동일해야한다
       	              		}
       	              	}
       	              	
       	                1) 메모리 저장
       	                   A aa=new A(); // 객체 생성 
       	                   
       	                   --aa----
       	                    0x100
       	                   --------
       	                            => . (주소 접근 연산자) 이용해서 접근
       	                            --0x100--
       	                            
       	                            ----a----
       	                               10   => aa.a
       	                            ---------
       	                              aaa() => aa.aaa()
       	                            ---------
       	                              bbb() => aa.bbb()
       	                            ---------
       	            => 리턴형이 있는 경우
       	               int a=aa.aaa();
       	               ---      ----- 데이터형 일치
       	            => 리턴형이 없는 경우 
       	               aa.bbb();
       	       = 공유 메소드 => static 
       	         형식)
       	           [접근지정어] static 리턴형 메소드명(매개변수 목록)
       	           {
       	              
       	           }
       	           static [접근지정어] 리턴형 메소드명(매개변수 목록)
       	           ( static 과 접근지정어 순서 바꿔도 되긴 한다 )
       	           => static 메소드는 static 변수,static 메소드 사용 가능
       	           => static 메소드 안에서는 인스턴스변수,메소드는 반드시 
       	              객체 생성 후 사용이 가능
       	       = 종단 메소드 => final => 상속을 방지
       	       = 선언만 한다 => 구현은 프로그램에 맞게 => abstract
       	         버튼 클릭 => 설계단과 관련 (추상클래스 / 인터페이스)
       	                                         ---------
       	                                     Spring이 인터페이스 기반 
       	     = 라이브러리 메소드 (9장)
       	       -------
       	        라이브러리 제공 VS 프레임워크 제공
       	        -------        -------
       	           |              |
       	         완제품(jar)       레고(java) => 전자정부,ANY
       	   -------------------------
       }
    2) 메모리 저장
       122p ==>
       객체생성 
       --- 기본형 => 변수 
       --- 클래스 => 객체 (메모리 공간)(주소를 이용)(=클래스의 변수)
       --- 하둡 : 만든 사람 아들의 장난감 이름 
       --- 클라우드 : 구글의 사장 말에서 유래 (네트워크 => 표현 구름)
객체생성시 : new 생성자()
       class A
       {
       }
       
       new A() => Thread() => new Thread() -> 알아서 동작 ,new 윈도우()
       ------- 메모리 주소 리턴 => 필요한 경우에는 주소를 저장
       A a=new A();
       
       ==> 123p => 객체 사용 
           A a=new A();
           a.변수,메소드
           
           A a;
           a=new A(); // 위 방식이 더 간편
    
    3) 호출
*/
class A{
//	int a=10; // 객체를 아래서 생성해줘야 메모리 저장된다
//	static int b=20; // 이미 메모리 안에 저장되어 있다
//
//	 void aaa() // 멤버메소드 (멤버변수,static 변수,지역변수 다 사용 가능)
//	 {
//		 System.out.println(a);
//		 System.out.println(b);
//	 }
//	 static void bbb() // static 메소드 (static 변수만 사용 가능)
//	 {
//		 A aa=new A();
//		 System.out.println(aa.a);
//		 System.out.println(b);
//	 }
	void display()
	{
		System.out.println("A:display Call...");
	}
	void aaa()
	{
		System.out.println("A:aaa Call...");
	}
}
public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		A aa=new A(); // aa라는 메모리에 a 인스턴스변수 저장 
//		System.out.println(aa.a);
//		System.out.println(aa.b);
//		System.out.println(A.b); // 클래스변수(공유변수)는 이렇게도 사용 가능
		
//		new A().display();
//		new A().aaa(); // 쓸데없이 메모리 낭비 중. 메모리 주소 2개 생성했기 때문
		A a=new A(); // 메모리 주소 1개만 생성 
		a.display();
		a.aaa();
	}

}
