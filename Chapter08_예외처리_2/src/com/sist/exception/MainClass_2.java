package com.sist.exception;
/*
	묶는 기술 => 객체 지향 ( 누가 더 잘 묶어서 사용하느냐 의 싸움 ) => 재사용 용이 
	
	1. 변수 묶는 방법 
	   = 배열 => 같은 데이터형 ( 메모리 크기가 동일해야 한다 => 연속적 메모리 구조 )
	            => 인덱스 이용 가능  
	   = 클래스 => 다른 데이터형 ( 메모리 주소 이용 (.) )
	2. 연산자 / 제어문 묶는 것 
	   = 메소드 (명령문을 묶어서 사용)
	--------------------------- 한개의 기능 => 부품 (컴포넌트)
	==> 조립 : 한개의 프로그램 
	==> 게시판 , 회원 , 맛집 , 채팅 , 예매 , 추천 , 결제 
	    ---------------------------------------- 다 모으면 맛집 사이트 
	    영화 사이트 : 게시판 , 회원 , 예약 , 추천 , 결제   --> 재사용 
	    ---------------------------------------- 수정(오버라이딩)
	------------------------------------------------------
	1. 가독성 2. 최적화(속도) 3. 견고성 
	            => Vue,React (JavaScript 보다 속도가 빠르다)
	----------------------------- 프로그램의 3대 형식
	1. 테스트 : 견고한 프로그램인지에 대한 => 사전에 에러를 방지하는 프로그램 
	                                 -----
	                                 => 예외처리 
	   견고 => 프로그래머의 실수 , 사용자 입력이 잘못된 경우 
	   ------------------------------------------
	2. 예외처리 
	   => 정의 : 사전에 에러를 방지 
	   => 목적 : 비정상 종료를 방지하고 정상 종료를 할 수 있게 만든다
	   ---
	   ---
	   --- 에러 => 건너뛰고 catch 로 이동 => 에러수정을 위한 확인 
	                                    에러를 복구
	   ---
	   ---
	   
	   => 예외처리 
	      1) 예외 복구 (try~catch)
	      2) 에러 회피 (throws)
	      3) 견고한 프로그램 
	         ----------- 확인위해 에러 발생 시켜본다 (임의 발생) => throw
	         => 매직 
	      4) 프로그램은 항상 ... 
	         모든 것을 지원하지 않는다 
	         => so 사용자 정의 
	         => 예약, 추천, 결제 ... 
	         => 사용자 정의 데이터형 Music, Movie ... 
	            => 기존의 데이터형을 모아서 새로운 데이터형을 제작
	               => class 
	         => 사용자 정의 메소드 
	         => 예외처리가 없는 경우 => 사용자 정의 예외처리
	      ------------------------------------------
	        결제모듈 ==> 보안처리 ==> 데이터베이스 
	        ------------------------------
	         | 솔루션 ==> 개발,SM(유지보수) / 영업 => 운영 
	           인원 : 20명 (솔루션)
	                 50명 (SI, 신규) , 150명 
   => 예외복구  
	  형식)
	      try
	      {
	      	 => 정상적으로 수행할 수 있는 명령문 
	      	 => 평상시 코딩 
	      	 문장 1
	      	 문장 2
	      	 문장 3
	      }catch(예외처리 클래스)
	      { 
	      	 => try 안에 있는 명령문에서 오류 발생시에
	      	    예외처리 / 복구 
	      } ==> catch 는 여러개 사용 가능 
	      finally ==> 생략가능 (필요한 경우에만 사용)
	      {
	      	 => try,catch 를 수행하든 관계없이 무조건 수행하는 문장
	      	 => 1) 서버 닫기 
	      	    2) 오라클 닫기 
	      	    3) 파일 닫기 
	      }
	      
	      실행 
	      문장 1
	      문장 2
	      try
	      {
	         문장 3
	       	 문장 4 ==> 에러 발생
	       	 문장 5
	      }catch(예외처리 클래스)
	      {
	       	 문장 6
	      }
	      finally
	      {
	         문장 7
	      }
	      문장 8 ==> 정상 종료
	      
	      1->2->3->4->5->7->8 => try 가 정상이면 catch 는 수행하지 않는다
	                             if ~ else 
	      1->2->3->6->7->8->
	      
	      
	      try
	      {
	      	 문장 1
	      	 문장 2 ==> C에러 발생 
	         문장 3
	      	     |     int[] arr=new int[2];
	      	     |     arr[2]=Integer.parseInt(" 10");
                 |            ----------------------- 우선순위 
                 |            -> NumberformatException 에러 출력 
	      }catch(A) -> (else if) // else if 처럼 catch 문은 하나만 수행 
	      {
	      	 A에 대한 에러 복구 => finally 이동 
	      }     |
	      catch(B) -> (else if)
	      {
	      	 B에 대한 에러 복구 => finally 이동 
	      }     |
	      catch(C) -> (else if)
	      {
	      	 C에 대한 에러 복구 => finally 이동
	      }
	      finally
	      {
	      	 닫기 
	      }
	      
	      catch 는 해당 영역에 한번만 수행 ==> 종료 
	      -------------------------------------
	
*/
import java.io.*;
public class MainClass_2 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		FileReader fr=new FileReader("/Users/maclovin/git/movie.txt"); // 예외처리 안해서 오류 발생
		FileReader fr = null;
		try
		{
			fr=new FileReader("/Users/maclovin/git/movie.txt");
//			String data=""; // Ajax                  VueJS 
			StringBuffer sb=new StringBuffer(); // StringBuffer 속도가 훨씬 빠름
			int i=0;
			while((i=fr.read())!=-1) // 파일 전체를 읽어올 때
			{
//				data+=(char)i;
				sb.append((char)i);
			}
//			System.out.println(data);
			System.out.println(sb.toString());
		}catch(IOException e)
		{
			// 오류 발생 ==> 에러 확인
			/*
			    에러 확인하는 방법 
				getMessage() => 에러 메세지만 출력 => null
				printStackTrace() => 권장 
				     ------------
				      |
				     실행 => 순서 => 멈춘다 ==> 에러 위치 확인 가능 
			*/
			e.printStackTrace(); // 에러 내용을 출력해달라.
		}
		finally
		{
//			fr.close(); // 오류나는 코드
			try
			{
				fr.close();
			}catch(IOException e) {}
		}
	}

}
